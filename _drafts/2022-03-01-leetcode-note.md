---
title: leetcode 笔记
layout: post
categories: algorithm
tags: golang leetcode
---

## 一、刷题策略：

- 重要的标签每个做 10-20 个。如，数组、字符串、链表、双指针、BFS、DFS、二叉树、二分法、分治法、回溯法、数学、栈、堆、队列等；
- 做完分类标签再做 Top100

| 类型     | 题号                                                         |
| -------- | ------------------------------------------------------------ |
| 数组     | 1、***4***、11、***42***、*53*、15、121、238、561、***85***、169、66、88、263、16、56、122、48、31、289、41、128、152、54、26、442、39... |
| 字符串   | 5、20、937、3、273、22、1249、68、49、415、76、10、17、91、6、609、93、227、680、767、12、8、67、126、13、336... |
| 二分查找 | 4、50、33、167、287、315、349、29、153、240、222、327、69、378、410、162、1111、35、34、300、363、350、209、354、278、374、981、174... |
| 哈希表   | 题目列表：1、771、3、136、535、138、85、202、149、49、463、739、76、37、347、336、219、18、217、36、349、560、242、187、204、500、811、609... |
| 链表     | 2、21、206、23、237、148、138、141、24、234、445、147、143、92、25、160、328、142、203、19、86、109、83、61、82、430、617... |
| 双指针   | 11、344、3、42、15、141、88、283、16、234、26、76、27、167、18、287、349、28、142、763、19、30、75、86、345、125、457、350... |
| 栈       | 42、20、85、155、739、173、1130、316、394、341、150、224、94、84、770、232、71、496、103、144、636、856、907、682、975、503、225、145... |
| 树       | 104、226、96、617、173、1130、108、297、100、105、95、124、654、669、99、979、199、110、236、101、235、114】94、222、102、938、437... |
| DFS      | 200、104、1192、108、301、394、100、105、695、959、124、99、979、199、110、101、114、109、834、116、679、339、133、332、547、257、546、364... |
| BFS      | 200、279、301、199、101、127、102、407、133、107、103、126、773、994、207、111、847、417、529、130、542、690、863、909、743、210、913... |
| 回溯法   | 22、17、46、10、39、37、79、78、51、93、89、357、131、140、77、306、1240、401、126、47、212、60、216、980、44、52、784、526... |
| 排序     | 148、56、147、315、349、179、253、164、242、220、75、280、327、973、324、767、350、296、969、57、1329、274、252、1122、493、1057、1152、1086... |

## 二、笔记

- 第 1 题，两数之和

  1. Golang 中 map 的 `, ok` 表示法： `if val, ok := map[key]; ok {`，查找 map 中是否存在对应下标的值。
  2. 哈希表（Map）在本题中的用法——记录数组中出现过的值（index）极其下标（value）。
  3. 两数之和转化为寻找 **和与其中一个数的差** 的问题。

- 第 11 题，盛最多水的容器

  1. 解题关键：距离越远，能盛水量越大；（最低）长度越高，能盛水量越大。
  2. golang 中没有求两数最小值的函数，需要自己实现。（因为没有重载？）
  3. 解题思路：用双指针分别指向数组头尾，向中间遍历，一轮以后即可求得最大面积。

- 第 53 题，最大子数组和

  1. 动态规划：存储计算过的值，后续直接调用，从而减少计算量。

  2. golang 的 range 可以用于 array、slice、channel、map。但是目标为切片特定片段时，返回的下标仍从 0 开始。如， [1:] ，key 仍为 0,1,...。

  3. 解题思路：以当前元素结尾的子数组和 = 当前元素 + 以前一元素结尾的子数组和。

  4. > 分治法求解还没看

- 第 15 题， 三数之和
  1. 排序+双指针：先固定第一个数a，然后b、c只能从两边向中间靠（在a之后），细节条件就是去重处理。
  2. 双指针移动指针策略：后两数之和小于第一个数，移动左指针（需要更大）；反之亦然。

- 第 121 题，买卖股票的最佳时机Ⅰ
  1. 错误原因：方向错了，考虑用盛水最多容器的双指针思路求解，但是股票价格没有面积的两个特点。
  2. 解题思路：用一个变量保存历史低价，计算今天卖是否收益最大，遍历一轮即可得到最大收益（DP 的思想？）。

- 第 238 题 除自身以外数组的乘积
  1. 解题思路：左右累乘，再分别乘左右累乘数组中的元素得到输出数组。
  2. 进阶技巧：将输出数组作为存放左累乘、最后结果的工具，右累乘用一个变量，可将空间复杂度降到 $$O(1)$$。

- 第 561 题，数组拆分
  1. 解题思路：其实就是生序数组第偶数序列下标和。
  2. golang 中将 int 数组排序的方法：`sort.Ints(array name)`。
  3. 循环可用 `i+=2`跳过奇数序列。

- 第 169 题，多数元素
  1. 解题思路1：排序并返回中间值；时间复杂度：O(nlogn)，空间复杂度：O(logn)【自带排序算法需要递归栈】。
  2. 解题思路2：哈希表（略）。
  3. 解题思路3：分治（暂时没看）
  4. **解题思路4：** **Boyer- Moore 投票算法**，**众数记为 -1，其他数记为 1，和大于 0**，计数器加减，归零就换众数值【有分治的思想】。

- 第 66 题，加一
  - 解题思路：找到最后一个不为 9 的元素将其加一，其后元素（全为 9）全部置 0。
  - **golang 中可以用 append 函数在切片任意位置添加元素**，如 `a = append([]int{1}, a...)`。

- 第 88 题，合并两个有序数组
  1. golang 中数组用 `append` 会报错 `first argument to append must be slice;`。

- 第 88 题，合并两个有序数组
  1. 错误原因：逆双指针没想好边界条件怎么处理。
  2. 处理关键：循环判断条件要带等号，且为或；边界条件要放在循环体里一起处理；以上两点就将边界纳入统一处理方式里了。

- 第 263 题，丑数

  1. 解题思路：不停的用待判断的数字除以质因数（2，3，5），最后判断商是否为 1。
  2. 不停的除需要用双重循环，外循环控制除数，内循环控制用目前除数不停地除。


- 第 16 题，最接近的三数之和

  1. 解题思路：排序+双指针。
  2. golang 中 32 位整数最大值为 `math.MaxInt32`。
  3. 需要定义：最接近的和值、当前和值。
  4. 移动指针的策略：根据**当前和值与目标值的大小**来判断指针移动。
- 第 56 题，合并区间
  1. Golang 中切片的（降序）排序 `sort.Slice(interface, func (a, b) bool {return a > b})`。
  2. 注意 golang 中切片的浅拷贝机制，通过修改切片下标赋值会引发其他引用该切边值一同产生变化。
  3. 解题思路：将二维数组各元素按第一个值的大小升序排序，再用双指针分析各情况合并。
- 第 57 题，买卖股票的最佳时机Ⅱ
  1. 解题关键：不要被题目“最佳时机”迷惑，要透过现象看本质，即找到数组中都是上升趋势的子区间的“和”，等价于“每天都买卖”【贪心】。
  2. 动态规划（暂时没看）。
- 第 48 题，旋转图像
  1. Golang 中 for 循环不能用 `for i, j :=0, n-1; i<j; i++, j--`，需要改为 `for i,  j:=0, n-1; i<j; i, j = i+1, j-1`。
  2. **先翻转（水平），再对称**比*先对称，再翻转（竖直）*好【数组在内存中存储结构决定的】。
  3. 其他思路：
     - 行 -> 列，\[row]\[cow] -> [col]\[n-row-1]，空间复杂度：$$O(n^2)$$
     - 原地旋转（暂时没看）

---


- 第 283 题，移动零
  1. Golang 中交换连个变量的值可直接用 `a, b = b, a`这种形式。
  2. 本来思路：微操双指针指向的两个值。
  3. 改进思路：左指针指向已排好的序列尾部(第一个 0），右指针指向为排序的序列头部（第一个不为 0）；初始时两指针重叠。
