---
title: leetcode 笔记
layout: post
categories: algorithm
tags: golang leetcode
---

## 一、刷题策略：

- 重要的标签每个做 10-20 个。如，数组、字符串、链表、双指针、BFS、DFS、二叉树、二分法、分治法、回溯法、数学、栈、堆、队列等；
- 做完分类标签再做 Top100

| 类型     | 题号                                                         |
| -------- | ------------------------------------------------------------ |
| 数组     | 1、***4***、11、***42***、*53*、15、121、238、561、***85***、169、66、88、263、16、56、122、48、31、289、***41***、128、152、54、26、442、39... |
| 字符串   | 5、20、937、3、***273***、22、1249、***68***、*49*、415、**76**、***10***、17、91、6、609、93、227、680、*767*、12、8、*67*、***126***、13、***336***... |
| 二分查找 | ***4***、**50**、33、167、287、***315***、349、29、153、240、222、327、69、378、410、162、1111、35、34、300、363、350、209、354、278、374、981、174... |
| 哈希表   | 1、771、3、136、535、138、85、202、149、49、463、739、76、37、347、336、219、18、217、36、349、560、242、187、204、500、811、609... |
| 链表     | 2、21、206、23、237、148、138、141、24、234、445、147、143、92、25、160、328、142、203、19、86、109、83、61、82、430、617... |
| 双指针   | 11、344、3、42、15、141、88、283、16、234、26、76、27、167、18、287、349、28、142、763、19、30、75、86、345、125、457、350... |
| 栈       | 42、20、85、155、739、173、1130、316、394、341、150、224、94、84、770、232、71、496、103、144、636、856、907、682、975、503、225、145... |
| 树       | 104、226、96、617、173、1130、108、297、100、105、95、124、654、669、99、979、199、110、236、101、235、114】94、222、102、938、437... |
| DFS      | 200、104、1192、108、301、394、100、105、695、959、124、99、979、199、110、101、114、109、834、116、679、339、133、332、547、257、546、364... |
| BFS      | 200、279、301、199、101、127、102、407、133、107、103、126、773、994、207、111、847、417、529、130、542、690、863、909、743、210、913... |
| 回溯法   | 22、17、46、10、39、37、79、78、51、93、89、357、131、140、77、306、1240、401、126、47、212、60、216、980、44、52、784、526... |
| 排序     | 148、56、147、315、349、179、253、164、242、220、75、280、327、973、324、767、350、296、969、57、1329、274、252、1122、493、1057、1152、1086... |

## 二、笔记

### 1. 数组

- 第 1 题，两数之和

  1. Golang 中 map 的 `, ok` 表示法： `if val, ok := map[key]; ok {}`，查找 map 中是否存在对应下标的值。
  2. 哈希表（Map）在本题中的用法——记录数组中出现过的值（index）极其下标（value）。
  3. 两数之和转化为寻找 **和与其中一个数的差** 的问题。

- 第 11 题，盛最多水的容器

  1. 解题关键：距离越远，能盛水量越大；（最低）长度越高，能盛水量越大。
  2. golang 中没有求两数最小值的函数，需要自己实现。（因为没有重载？）
  3. 解题思路：用双指针分别指向数组头尾，向中间遍历，一轮以后即可求得最大面积。

- 第 53 题，最大子数组和

  1. 动态规划：存储计算过的值，后续直接调用，从而减少计算量。

  2. golang 的 range 可以用于 array、slice、channel、map。但是目标为切片特定片段时，返回的下标仍从 0 开始。如， [1:] ，key 仍为 0,1,...。

  3. 解题思路：以当前元素结尾的子数组和 = 当前元素 + 以前一元素结尾的子数组和【计算时要改变原数组】。

  4. > 分治法求解还没看

- 第 15 题， 三数之和
  1. 排序+双指针：先固定第一个数a，然后b、c只能从两边向中间靠（在a之后），细节条件就是去重处理。
  2. 双指针移动指针策略：后两数之和小于第一个数，移动左指针（需要更大）；反之亦然。

- 第 121 题，买卖股票的最佳时机Ⅰ
  1. 错误原因：方向错了，考虑用盛水最多容器的双指针思路求解，但是股票价格没有面积的两个特点。
  2. 解题思路：用一个变量保存历史低价，计算今天卖是否收益最大，遍历一轮即可得到最大收益（DP 的思想？）。

- 第 238 题 除自身以外数组的乘积
  1. 解题思路：左右累乘，再分别乘左右累乘数组中的元素得到输出数组。
  2. 进阶技巧：将输出数组作为存放左累乘、最后结果的工具，右累乘用一个变量，可将空间复杂度降到 $$O(1)$$。

- 第 561 题，数组拆分
  1. 解题思路：其实就是生序数组第偶数序列下标和。
  2. golang 中将 int 数组排序的方法：`sort.Ints(array name)`。
  3. 循环可用 `i+=2`跳过奇数序列。

- 第 169 题，多数元素
  1. 解题思路1：排序并返回中间值；时间复杂度：O(nlogn)，空间复杂度：O(logn)【自带排序算法需要递归栈】。
  2. 解题思路2：哈希表（略）。
  3. 解题思路3：分治（暂时没看）
  4. **解题思路4：** **Boyer- Moore 投票算法**，**众数记为 -1，其他数记为 1，和大于 0**，计数器加减，归零就换众数值【有分治的思想】。

- 第 66 题，加一
  - 解题思路：找到最后一个不为 9 的元素将其加一，其后元素（全为 9）全部置 0。
  - **golang 中可以用 append 函数在切片任意位置添加元素**，如 `a = append([]int{1}, a...)`。

- 第 88 题，合并两个有序数组
  1. golang 中数组用 `append` 会报错 `first argument to append must be slice;`。

- 第 88 题，合并两个有序数组
  1. 错误原因：逆双指针没想好边界条件怎么处理。
  2. 处理关键：循环判断条件要带等号，且为或；边界条件要放在循环体里一起处理；以上两点就将边界纳入统一处理方式里了。

- 第 263 题，丑数

  1. 解题思路：不停的用待判断的数字除以质因数（2，3，5），最后判断商是否为 1。
  2. 不停的除需要用双重循环，外循环控制除数，内循环控制用目前除数不停地除。


- 第 16 题，最接近的三数之和

  1. 解题思路：排序+双指针。
  2. golang 中 32 位整数最大值为 `math.MaxInt32`。
  3. 需要定义：最接近的和值、当前和值。
  4. 移动指针的策略：根据**当前和值与目标值的大小**来判断指针移动。
- 第 56 题，合并区间
  1. Golang 中切片的（降序）排序 `sort.Slice(interface, func (a, b) bool {return a > b})`。
  2. 注意 golang 中切片的浅拷贝机制，通过修改切片下标赋值会引发其他引用该切边值一同产生变化。
  3. 解题思路：将二维数组各元素按第一个值的大小升序排序，再用双指针分析各情况合并。
- 第 57 题，买卖股票的最佳时机Ⅱ
  1. 解题关键：不要被题目“最佳时机”迷惑，要透过现象看本质，即找到数组中都是上升趋势的子区间的“和”，等价于“每天都买卖”【贪心】。
  2. 动态规划（暂时没看）。
- 第 48 题，旋转图像
  1. Golang 中 for 循环不能用 `for i, j :=0, n-1; i<j; i++, j--`，需要改为 `for i,  j:=0, n-1; i<j; i, j = i+1, j-1`。
  2. **先翻转（水平），再对称**比*先对称，再翻转（竖直）*好【数组在内存中存储结构决定的】。
  3. 其他思路：
     - 行 -> 列，\[row]\[cow] -> [col]\[n-row-1]，空间复杂度：$$O(n^2)$$
     - 原地旋转（暂时没看）
- 第 31 题，下一个排列
  1. golang 中将函数赋值给变量 `a := func(args...) [type] {}`，应用 `a(args...)`。
  2. Golang 中 for 循环语句定义的控制变量只能在循环体里用，如 `for  i := 0;...`，i 不能在 for 之外使用。
  3. 解题思路：**两遍扫描**，将尽可能“靠右”序列中较小的与尽可能靠右的大数的互换。
     - 第一遍扫描：从后往前找出第一组降序序列
     - 第二遍扫描：将最靠右的比降序序列大的值与其交换，并将其后的序列逆序（即，变成递增序列）
- 第 289 题，生命游戏
  1. 错误原因：理解错题意，
     - 要同时更新面板（二维数组）状态，必须要记录初始态；
     - 边界相邻的细胞不是 8 个，不用模运算。
  2. 解题思路：可通过 `-1, 2`等值表示状态变化，即可反推出初始态进行调节。
- 第 41 题，缺失的第一个正数
  1. 解题思路：【置换】遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，否则遍历完都没出现那么答案就是数组长度加1。
  2. 注意事项：置换的代码要满足 $$ 0 \leq{nums[i]}\leq{n} \&\& nums[nums[i]-1] != nums[i]$$。
  3. 哈希表法（暂时没看）

---

### 2. 字符串

- 第 20 题，有效的括号

  1. golang 字符串的实现 byte（uint8）、rune（int32）
  2. **代码点**：字符对应的 unicode 编码；**符文（rune）**；**字节（byte）**。
  3. golang 可以用单引号包裹字符获取其对应的代码点。
  4. golang 中 range 可以解码 UTF-8 编码的字符串。
  5. golang 中可以用反引号包裹字符串使字符串不转义。

- 第 5 题，最长回文子串

  1. 解题方法：中心扩散（暂时没看）、动态规划、Manacher（马拉车）算法（暂略）。

  2. 动态规划：

     - 状态转移方程
     - 计算边界条件
     - 初始化

  3. golang 初始化二维数组

     ```go
     var dp [][]bool // dp := make([][]bool, 0)
     m, n := 123 // 
     for i:=0; i<m; i++ {
       row := make([]bool, n)
       dp = append(dp, row)
     }
     ```

- 第 937 题，重新排列日志文件

  1. Golang 中 `sort.Slice(<slice name>, <less func>)` 与`sort.Slice Stable(<slice name>, <less func>)` 的区别。
  2. golang 中 `strings.Split(<string>, "seq")`与`strings.SplitN(<string>, "seq", N) `的区别。
  3. golang 中 判断字符串是否为数字 `unicode.IsDigit(string  rune)`。
  4. ？golang 中 比较字符串的大小 `< > == `？。

- 第 3 题， 无重复字符的最长子串

  1. 解题思路：滑动窗口
  2. 滑动窗口的初始指针：`l:0; r:-1`
  3. 滑动窗口逐个字符向右滑动（配合删除哈希表中元素）

- 第 22 题，括号生成

  1. 回溯算法模板（可以依据情况添加减枝操作，一般改变循环条件即可）

     ```go
     var path []int
     var result [][]int
     
     func backtracing(args...) {  // args 需要根据题意确定，如集合大小 n、目标大小 k，遍历开始位置 startIndex、结果集合 result、路径集合 path 等
       if len(path) == k {  // 递归终止条件
         result = append(result, path)
         return
       }
       for i:=startIndex; i<n; i++ {  // 递归内循环，确定单层搜索逻辑 i< n- (k - path.size)+1 剪枝
         path = append(path, i)  // 路径入栈
         backtracing(args...)  // 嵌套递归
         path = delet(path, xx)  // 路径出栈
       }
     }
     ```

  2. golang 中若要使用变量为递归函数的函数型变量（自己调用自己），要用 var 声明才能自己调用自己

- 第 1249 题，移除无效括号

  1.  golang 中字符串不能直接操作，可以转为 `[]rune` 数组进行操作：`str := []rune(s)`。
  2. 解题思路：计数器 + StringBuilder 两步法：
     - 从左往右移除非法的 ")"；
     - 从右往左移出非法的"("；
     - 将标记位剔除。
  3. golang 中字符串剔除标记位的函数：`strings.ReplaceAll(s, old, new string)`。
  4. 注意 golang 中设置标记位要用代码点，如 `'0'`，不要直接用 ASCII 码。

- 第 415 题，字符串相加

  1. golang 中模拟时，因 数字 对应的 ASCII 码都是两位数，故可用步进的方式遍历字符串得到代码点。
  2. 易错点：返回拼接的字符串时，要用`res = <本轮计算结果> + res`，而不能用 `+=`，否则会倒序。

- 第 76 题， 最小覆盖子串

  1. 解题思路：滑动窗口 

  2. 滑动窗口模板：

     ```go
     ...
     for r<length {
       // 对 r 指向元素的判断、操作
      ...
       r++
       // 对 l 的判断、操作
       for condition {
         ...
         l++
       }
     }
     ```

  3. 检查窗口是否包含目标子串：

     - 可在每次操作时用 for 循环查询 哈希表。
     - 或 定义一个变量 distance，在操作左右指针时修改 distance 的值（类似计数器）。

- 第 17 题，电话号码的字母组合

  1. 关键思路：通过确定递归的层数 depth 来确认要加入 path 的字符

  2. golang 中，对切片进行 append 切片时，要进行一次切片拷贝，怕之后的操作影响待 append 切片内的值。

     ```go
     //进行一次切片拷贝，怕之后的操作影响tmpString切片内的值
             t := make([]string, len(tmpString))
     		copy(t, tmpString)
             *res=append(*res,t)
     ```

     

- 第 91 题， 解码方法

  1. 错误原因：回溯超时，**要观察输入的长度来决定递不递归**。
  2. 解题思路：动态规划：
     - dp[i] 表示字符串 s 前 i 个字符的解码方法数目。
       1. 使用一个字符进行解码 $$f_i = f_{i-1}, s[i]\neq{0}$$；
       2. 使用两个字符进行编码 $$ f_i = f_{i-2}, s[i-1]\neq{0}  \&\&10\times{s[i-1]}+s[i]\leq{26}$$；
       3. $$f_0=1$$。
     - 优化思路：$$f_i$$ 仅与 $$f_{i-1}, f_{i-2}$$有关，不用维护动态规划数组，只用常数存储即可。

- 第 6 题，Z 子形变换

  1. 错误原因：
     - 直接构造时，没抽象出“整体”的周期性。
     - 考虑周期时，没考虑边界情况，即 numRows == 1 或 numRows > len(s)。
     - 不知道内循环的结束条件是啥。
  2. 关键点：根据周期性确定来构造内循环：
     - `for j:=0; i+j<n; j+=t`，内循环为周期开始的字符下标；
     - 非首尾行还要判断是否越界，即 s[j+t-i]\(s[i+j+t-2i])<n。

- 第 609 题，在系统中查找重复文件

  1. 解题方法：哈希表，key 存储文件内容、val 存储文件路径（数组）。
  2. golang 中获取字符串最后一次出现字符串的下标函数 `strings.LastIndex`


- 第 93 题，复原 IP 地址
  1. 回溯与 DFS 区别：其实没啥区别。
  2. 回溯中递归的终止条件可能不唯一，满足结果的可以加入结果集返回（回溯），不满足的也可以直接返回（回溯）。
  3. 易错点：验证是否符合 IP 规则时，验证 字符串前导为 0 ，一定要验证字符串长度大于 1。
  4. golang 中 字符串数组转化为字符串可用 `strings.Join(string, seg)// seg 为分割字符串`。

- 第 227 题，基础计算器 II
  1. 解题思路：取消操作符号栈，将 +、- 作为直接赋值给其后面的数字，*、/ 用来操作栈顶和当前数字并入栈
  2. 注意点：
     - s 要加一个操作符，否则会少做一次运算
     - 连续数字要循环过程将之前*10 + 当前数字组合

- 第 680 题，验证回文字符串 II
  1. 解题方法：双指针+贪心。
  2. 具体算法：双指针判断目标串是否是回文串，如果左右指针不等，则或删除左指针对应字符，或删除右指针对应字符，判断剩下的字符串是否为回文串即可。

- 第 12 题，整数转罗马数字
  1. 解题方法1: 模拟。即待处理数组/罗马字符对应的数字，值为拼接的罗马字符串，待处理数字取余为新的待处理数字。
  2. 解题方法2: 硬编码（取值范围为1-3999）。将，0-9，千百十个，分别作为行列值，绘制一张表格，进行硬编码。

- 第 8 题，字符串转换整数（atoi）
  1. 解题方法1（模拟法）： 去掉空格，确定符号，获得数字（循环中不断判断是否越界）。
  2. 解题方法2（状态机）：画出状态转换图，转化为表格，代码实现之。

- 第 67 题，二进制求和

  1. 解题方法（大数包的调用）

     ```go
     func addBinary(a string, b string) string {
     
     	ai, _ := new(big.Int).SetString(a, 2)
     	bi, _ := new(big.Int).SetString(b, 2)
     
     	ai.Add(ai, bi)
     	return ai.Text(2)
     }
     ```

- 第 13 题，罗马数字转整数

  1. 解题方法：模拟。字典中不用表示 4、9、40、90 等组合情况（不能用 byte 表示组合字符）。
  2. 关键思路：正确的罗马表示法，若两个字符组合表示一个值，往往前一个值比后一个值小（此处的大小不是字符串 ASCII 码的大小，而是罗马字符对应的阿拉伯数字的大小）。
  3. 注意：'a' ：即可以为 byte 型，也可以为 rune 型。

---

### 3. 二分查找

- 第 50 题，Pow(x, n)
  1. 解题方法：分治法。f(n) = f(n/2) * f(n/2)【从右往左看】
  2. 解题方法 2: 分治法（非递归）。累乘分解为指数的二进制累乘相乘（见代码）【从左往右找规律】。
     - 位操作取 x 最低位的两种方法：`x&(-x)`或`x-(x&(x-1))`
  3. 注意事项：**n 的正负号要考虑**
  
- 第 33 题，搜索旋转排序数组

  1. 解题方法：二分查找（变种）。
  
     将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序：
  
     - 此时有序部分用二分法查找；
     - 无序部分再一分为二，其中一个
     - 一定有序，另一个可能有序，可能无序。
  
     如此循环。 
  
  2. 关键点：
  
     - 目标值要与区间端点比较（要有等号）。
     - 判断区间有序时比较区间端点时也要有等号。
  
  3. 解题方法 2：模拟计算（不推荐）。先找出旋转下标 k，后通过模拟原数组二分查找。
  
     关键点：原数组 -> 旋转后数组 下标变化：x -> (x+len-k)%len，其中 len 为数组长度。
  
     ​				旋转后数组 -> 原数组 下标变化： y -> (x+len+k)%len。
  
- 第 167 题，两数之和 II - 输入有序数组

  1. 解题方法 1：双指针法。数组有序即可通过与目标值的比较来制定移动左右指针的策略。
  2. 解题方法 2：折半查找。固定一个加数，用折半查找来查找另一个加数。

- 第 287 题，寻找重复数

  1. 值域的二分查找。需要两重循环。

     ```go
     for l<=r {
       mid := (l+r)/2
       cnt :=0
       for i:=0; i<n; i++ { // 统计值小于等于值域一半的元素的梳理
         if nums[i] <= mid {
           cnt++
         }
       }
       if cnt > mid{
         r = mid -1
         res = mid // 重复元素在[l, mid]区间，结果暂时定为 mid
       } else {
         l = mi+1
       }
     }
     ```

  2. 快慢指针法。两重循环，第一重退出条件为第一次相遇；第二重快指针调整为与慢指针速度相同时从头开始，慢指针继续原位置开始，退出条件为第二次相遇，相遇点即为入环点。

     - 注意：判断相等的条件为 slow == fast，而不是 nums[slow] == nums[fast]。因为 指针为下一次的索引和本次的值。

  3. 二进制展开（暂略）

- 第 349 题，两个数组的交集

  1. 解题思路：哈希表、排序+双指针（没看）







---


- 第 283 题，移动零
  1. Golang 中交换连个变量的值可直接用 `a, b = b, a`这种形式。
  2. 本来思路：微操双指针指向的两个值。
  3. 改进思路：左指针指向已排好的序列尾部(第一个 0），右指针指向为排序的序列头部（第一个不为 0）；初始时两指针重叠。

​	

```go
func reorderLogFiles(logs []string) []string {
	sort.SliceStable(logs, func(i, j int) bool {
		split1 := strings.SplitN(logs[i], " ", 2)
		split2 := strings.SplitN(logs[j], " ", 2)
		isDigit1 := unicode.IsDigit(rune(split1[1][0]))
		isDigit2 := unicode.IsDigit(rune(split2[1][0]))
		if !isDigit1 && !isDigit2 {
			return split1[1] < split2[1] || (split1[1] == split2[1] && split1[0] < split2[0])
		}
		return !isDigit1 && isDigit2
	})
	return logs
}
```

