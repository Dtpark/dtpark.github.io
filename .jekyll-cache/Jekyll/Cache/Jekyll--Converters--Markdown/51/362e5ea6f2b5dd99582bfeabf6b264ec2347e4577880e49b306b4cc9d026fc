I" <h2 id="0x01-题目">0x01 题目</h2>

<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>

<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>

<p> </p>

<p>示例：</p>

<blockquote>
  <p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
</blockquote>

<blockquote>
  <p>返回链表 4-&gt;5.</p>
</blockquote>

<h2 id="0x02-暴力求解栈">0x02 暴力求解/【栈】</h2>

<p>将链表转化为数组，通过计算数组长度得到链表长度 length 。使用 <code class="language-plaintext highlighter-rouge">length - k</code> 得到目标节点指针。</p>

<p>复杂度分析：</p>
<blockquote>
  <p>时间复杂度：O(n)<br />
空间复杂度：O(n)</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */</span>
<span class="k">func</span> <span class="n">getKthFromEnd</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
    <span class="n">indexArr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="n">ListNode</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">:=</span> <span class="n">head</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">indexArr</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">indexArr</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">Next</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">Next</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexArr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indexArr</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="0x03-快慢指针">0x03 快慢指针</h2>

<p>快慢指针的思想。我们将第一个指针 fast 指向链表的第 k+1 个节点，第二个指针 slow 指向链表的第一个节点，此时指针 fast 与 slow 二者之间刚好间隔 k 个节点。此时两个指针同步向后走，当第一个指针 fast 走到链表的尾部空节点时，则此时 slow 指针刚好指向链表的倒数第 k个节点。</p>

<ul>
  <li>我们首先将 fast 指向链表的头节点，然后向后走 k 步，则此时 fast 指针刚好指向链表的第 k+1 个节点。</li>
  <li>我们首先将 slow 指向链表的头节点，同时 slow 与 fast 同步向后走，当 fast 指针指向链表的尾部空节点时，则此时返回 slow 所指向的节点即可。</li>
</ul>

<p>复杂度分析：</p>
<blockquote>
  <p>时间复杂度：O(n)<br />
空间复杂度：O(1)</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">getKthFromEnd</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">ListNode</span> <span class="p">{</span>
    <span class="n">fast</span><span class="p">,</span> <span class="n">slow</span> <span class="o">:=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span>
    <span class="k">for</span> <span class="n">fast</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">Next</span>
        <span class="n">k</span><span class="o">--</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">fast</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">Next</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">Next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">slow</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="0x04-顺序查找">0x04 顺序查找</h2>

<p>最简单直接的方法即为顺序查找，假设当前链表的长度为 n，则我们知道链表的倒数第 k 个节点即为正数第 n−k 个节点，此时我们只需要顺序遍历到链表的第 n−k 个节点即为倒数第 k 个节点。</p>
<ul>
  <li>我们首先求出链表的长度 n，然后顺序遍历到链表的第 n−k 个节点返回即可。</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">getKthFromEnd</span><span class="p">(</span><span class="n">head</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">,</span> <span class="n">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">kth</span> <span class="o">*</span><span class="n">ListNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="k">for</span> <span class="n">node</span> <span class="o">:=</span> <span class="n">head</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">Next</span> <span class="p">{</span>
        <span class="n">n</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">kth</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span> <span class="p">{</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="n">kth</span><span class="o">.</span><span class="n">Next</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>复杂度分析：</p>
<blockquote>
  <p>时间复杂度：O(n)
空间复杂度：O(1)</p>
</blockquote>

<h2 id="0x05-心得">0x05 心得</h2>

<p>不要觉得多几次循环时间复杂度就一定高，毕竟复杂度描述的是规模，不是很精确的定量分析。</p>

<h2 id="0x06-参考资料">0x06 参考资料</h2>

<ul>
  <li>[1] 题目来源：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</li>
  <li>[2] 部分题解来源：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/lian-biao-zhong-dao-shu-di-kge-jie-dian-1pz9l/</li>
</ul>

:ET